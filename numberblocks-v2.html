import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Trophy, PlusCircle, RotateCcw, Zap, Sparkles, Layout, Trash2, Scissors, Star, RefreshCw } from 'lucide-react';

// --- UTILIDADES DE SONIDO (Sintetizador Web Audio) ---
const playSound = (type) => {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  if (!AudioContext) return;
  
  const ctx = new AudioContext();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  
  osc.connect(gain);
  gain.connect(ctx.destination);
  
  const now = ctx.currentTime;

  switch(type) {
    case 'spawn':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;
    case 'merge':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(330, now);
      osc.frequency.exponentialRampToValueAtTime(660, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'transform':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(523, now);
      osc.frequency.linearRampToValueAtTime(783, now + 0.1);
      osc.frequency.linearRampToValueAtTime(523, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'split':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(660, now);
      osc.frequency.exponentialRampToValueAtTime(220, now + 0.15);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;
    case 'success':
      const notes = [523.25, 659.25, 783.99, 1046.50]; 
      notes.forEach((freq, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.connect(g);
        g.connect(ctx.destination);
        o.frequency.setValueAtTime(freq, now + (i * 0.1));
        g.gain.setValueAtTime(0.05, now + (i * 0.1));
        g.gain.exponentialRampToValueAtTime(0.01, now + (i * 0.1) + 0.3);
        o.start(now + (i * 0.1));
        o.stop(now + (i * 0.1) + 0.3);
      });
      break;
    default:
      break;
  }
};

const getBlockStyle = (value) => {
  if (value <= 10) {
    const config = {
      1: { bg: '#FF0000', border: 'rgba(0,0,0,0.15)' },
      2: { bg: '#FF8000', border: 'rgba(0,0,0,0.15)' },
      3: { bg: '#FFFF00', border: 'rgba(0,0,0,0.15)' },
      4: { bg: '#00FF00', border: 'rgba(0,0,0,0.15)' },
      5: { bg: '#00FFFF', border: 'rgba(0,0,0,0.15)' },
      6: { bg: '#8A2BE2', border: 'rgba(0,0,0,0.15)' },
      7: { bg: 'linear-gradient(45deg, #ff0000, #ffff00, #00ff00, #0000ff)', border: 'rgba(0,0,0,0.15)' },
      8: { bg: '#FF69B4', border: 'rgba(0,0,0,0.15)' },
      9: { bg: '#C0C0C0', border: 'rgba(0,0,0,0.15)' },
      10: { bg: '#FFFFFF', border: '#FF0000' },
    };
    return config[value];
  }
  if (value === 100) return { bg: '#FFFFFF', border: '#FF0000', glow: '0 0 25px rgba(255,0,0,0.2)' };
  const tens = Math.floor(value / 10);
  const hue = (tens * 36) % 360;
  return { bg: `hsl(${hue}, 85%, 75%)`, border: value % 10 === 0 ? '#FF0000' : 'rgba(0,0,0,0.12)' };
};

// Obtener todos los anchos válidos (que mantengan altura >= 2)
const getValidWidths = (value) => {
  if (value === 1) return [1];
  const widths = [];
  const maxWidth = value >= 12 ? 6 : 4;
  for (let i = 1; i <= Math.min(value, maxWidth); i++) {
    if (value % i === 0 && (value / i) >= 2) {
      widths.push(i);
    }
  }
  return widths.length > 0 ? widths : [1];
};

const NumberBlock = React.memo(({ value, x, y, id, width, onPointerDown, onDoubleClick, onRotate, highlight = false }) => {
  const style = getBlockStyle(value);
  const cols = width || 1;
  const rows = Math.ceil(value / cols);

  let blockSize = 34;
  if (rows > 10) blockSize = 20;
  else if (rows > 7) blockSize = 24;
  else if (rows > 5) blockSize = 28;
  else if (value > 20) blockSize = 30;

  const validWidths = getValidWidths(value);
  const canTransform = validWidths.length > 1;

  // Manejador de scroll para simular pellizco/rotación
  const handleWheel = (e) => {
    if (canTransform) {
      e.preventDefault();
      onRotate(id);
    }
  };

  return (
    <div
      id={`block-${id}`}
      data-value={value}
      data-width={cols}
      data-bsize={blockSize}
      onPointerDown={(e) => onPointerDown(e, id)}
      onDoubleClick={(e) => { e.stopPropagation(); onDoubleClick(id); }}
      onWheel={handleWheel}
      className={`group absolute touch-none select-none flex flex-col-reverse items-center transition-all ${value === 100 ? 'z-50' : 'z-10'}`}
      style={{
        left: x,
        top: y,
        transform: 'translate(-50%, -100%)',
        cursor: 'grab',
        transition: 'transform 0.15s cubic-bezier(0.2, 0, 0.2, 1)'
      }}
    >
      {(highlight || value === 100) && (
        <div className={`absolute inset-x-[-50px] inset-y-[-40px] blur-3xl rounded-full animate-pulse z-0 ${value === 100 ? 'bg-red-400/20' : 'bg-white/60'}`} />
      )}

      <div className={`relative z-10 transition-all ${highlight ? 'scale-105' : ''}`}>
        {/* Botón de Transformación (Visible en hover) */}
        {canTransform && (
          <button
            onPointerDown={(e) => { e.stopPropagation(); onRotate(id); }}
            className="absolute -right-6 top-0 bg-white shadow-md rounded-full p-1 border border-slate-200 text-sky-500 hover:bg-sky-50 hover:scale-110 active:scale-95 transition-all opacity-0 group-hover:opacity-100 z-50"
          >
            <RefreshCw size={14} />
          </button>
        )}

        <div 
          className="grid gap-0" 
          style={{ 
            gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
            width: `${cols * blockSize}px`,
            border: `1px solid ${style.border}`,
            boxShadow: style.glow || 'none'
          }}
        >
          {Array.from({ length: value }).map((_, i) => {
            const faceIndex = Math.floor(cols / 2);
            const isFaceBlock = i === faceIndex; 

            return (
              <div
                key={i}
                className="relative flex items-center justify-center"
                style={{ 
                  width: `${blockSize}px`,
                  height: `${blockSize}px`,
                  background: style.bg,
                  border: `0.5px solid rgba(0,0,0,0.1)`
                }}
              >
                {isFaceBlock && (
                  <div className={`absolute inset-0 flex flex-col items-center justify-center ${blockSize < 25 ? 'scale-75' : 'scale-90'}`}>
                    <div className="flex gap-1 mb-1">
                      {value === 1 ? (
                        <div className="w-4 h-4 bg-black rounded-full border-2 border-white" />
                      ) : (
                        <>
                          <div className="w-2.5 h-2.5 bg-black rounded-full border-2 border-white" />
                          <div className="w-2.5 h-2.5 bg-black rounded-full border-2 border-white" />
                        </>
                      )}
                    </div>
                    <div className="w-5 h-2 bg-black/25 rounded-full" />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>
      
      <div className={`mb-1 font-black pointer-events-none z-20 text-black flex items-center gap-1 ${value >= 100 ? 'text-2xl' : 'text-base'}`}>
        {value === 100 && <Star size={16} className="fill-red-500 text-red-500 animate-spin-slow" />}
        {value}
        {value === 100 && <Star size={16} className="fill-red-500 text-red-500 animate-spin-slow" />}
      </div>

      {value > 1 && (
        <div className="absolute -top-10 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
          <Scissors size={14} className="text-slate-400 rotate-90" />
        </div>
      )}
    </div>
  );
});

const App = () => {
  const [blocks, setBlocks] = useState([]);
  const [target, setTarget] = useState(10);
  const [score, setScore] = useState(0);
  const [highlightId, setHighlightId] = useState(null);
  const [isFreeMode, setIsFreeMode] = useState(false);
  const containerRef = useRef(null);
  const draggingRef = useRef({ id: null, element: null, offsetX: 0, offsetY: 0, currentX: 0, currentY: 0 });

  const nextLevel = useCallback(() => {
    const newTarget = Math.floor(Math.random() * 91) + 10;
    setTarget(newTarget);
    setBlocks([
      { id: 'b1', value: 1, x: 80, y: 350, width: 1 },
      { id: 'b2', value: 1, x: 150, y: 350, width: 1 }
    ]);
    setHighlightId(null);
  }, []);

  useEffect(() => { nextLevel(); }, [nextLevel]);

  const rotateBlock = (id) => {
    playSound('transform');
    setBlocks(prev => prev.map(b => {
      if (b.id !== id) return b;
      const validWidths = getValidWidths(b.value);
      if (validWidths.length <= 1) return b;
      
      const currentIndex = validWidths.indexOf(b.width);
      const nextIndex = (currentIndex + 1) % validWidths.length;
      return { ...b, width: validWidths[nextIndex] };
    }));
  };

  const spawnBlock = (val) => {
    playSound('spawn');
    const rect = containerRef.current.getBoundingClientRect();
    const newBlock = {
      id: `block-${Date.now()}`,
      value: val,
      x: Math.random() * (rect.width - 150) + 75,
      y: rect.height - 40,
      width: getValidWidths(val)[0]
    };
    setBlocks(prev => [...prev, newBlock]);
  };

  const splitBlock = (id) => {
    playSound('split');
    setBlocks(prev => {
      const blockToSplit = prev.find(b => b.id === id);
      if (!blockToSplit || blockToSplit.value <= 1) return prev;
      const newValue = blockToSplit.value - 1;
      const updatedBlock = { ...blockToSplit, value: newValue, width: getValidWidths(newValue)[0] };
      const newOne = { id: `split-${Date.now()}`, value: 1, x: blockToSplit.x + 40, y: blockToSplit.y, width: 1 };
      return [...prev.filter(b => b.id !== id), updatedBlock, newOne];
    });
  };

  const checkCollision = (dragId, x, y) => {
    const otherElements = Array.from(document.querySelectorAll(`[id^="block-"]:not(#block-${dragId})`));
    for (let el of otherElements) {
      const rect = el.getBoundingClientRect();
      const containerRect = containerRef.current.getBoundingClientRect();
      const elX = rect.left - containerRect.left + rect.width / 2;
      const elY = rect.bottom - containerRect.top;
      const val = parseInt(el.getAttribute('data-value'));
      const widthUnits = parseInt(el.getAttribute('data-width'));
      const bSize = parseInt(el.getAttribute('data-bsize'));
      const heightUnits = Math.ceil(val / widthUnits);
      const pxWidth = widthUnits * bSize;
      const pxHeight = heightUnits * bSize;
      const thresholdX = (pxWidth / 2) + 20; 
      const thresholdY = 20; 
      const isInsideX = Math.abs(x - elX) < thresholdX;
      const isInsideY = y > (elY - pxHeight - thresholdY) && y < (elY + thresholdY);
      if (isInsideX && isInsideY) return el.id.replace('block-', '');
    }
    return null;
  };

  const handlePointerDown = (e, id) => {
    const blockElement = document.getElementById(`block-${id}`);
    if (!blockElement) return;
    const rect = containerRef.current.getBoundingClientRect();
    const blockData = blocks.find(b => b.id === id);
    draggingRef.current = { id, element: blockElement, offsetX: e.clientX - rect.left - blockData.x, offsetY: e.clientY - rect.top - blockData.y, currentX: blockData.x, currentY: blockData.y };
    blockElement.style.zIndex = "1000";
    blockElement.style.transition = "none";
    blockElement.setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e) => {
    const state = draggingRef.current;
    if (!state.id) return;
    const rect = containerRef.current.getBoundingClientRect();
    state.currentX = e.clientX - rect.left - state.offsetX;
    state.currentY = e.clientY - rect.top - state.offsetY;
    state.element.style.left = `${state.currentX}px`;
    state.element.style.top = `${state.currentY}px`;
    const targetId = checkCollision(state.id, state.currentX, state.currentY);
    setHighlightId(targetId);
  };

  const handlePointerUp = (e) => {
    const state = draggingRef.current;
    if (!state.id) return;
    const targetId = checkCollision(state.id, state.currentX, state.currentY);
    if (targetId) {
      const sourceBlock = blocks.find(b => b.id === state.id);
      const targetBlock = blocks.find(b => b.id === targetId);
      const newValue = sourceBlock.value + targetBlock.value;
      
      if (newValue <= 100) {
        playSound('merge');
        const remainingBlocks = blocks.filter(b => b.id !== state.id && b.id !== targetId);
        const mergedBlock = {
          id: `merged-${Date.now()}`,
          value: newValue,
          x: targetBlock.x,
          y: targetBlock.y,
          width: getValidWidths(newValue)[0]
        };
        setBlocks([...remainingBlocks, mergedBlock]);
        if (!isFreeMode && newValue === target) {
          playSound('success');
          setScore(s => s + 1);
          setTimeout(() => { setBlocks([]); setTimeout(nextLevel, 400); }, 1500);
        }
      }
    } else {
      setBlocks(prev => prev.map(b => b.id === state.id ? { ...b, x: state.currentX, y: state.currentY } : b));
    }
    state.element.style.zIndex = "10";
    state.element.style.transition = "transform 0.2s, left 0.2s, top 0.2s";
    state.id = null; setHighlightId(null);
  };

  return (
    <div className="flex flex-col h-screen bg-sky-50 overflow-hidden font-sans select-none">
      <div className="bg-white p-2 flex justify-between items-center shadow-sm border-b-2 border-sky-100 z-50">
        <div className="flex items-center gap-2">
          {!isFreeMode && (
            <div className="flex items-center gap-1.5">
              <div className="bg-orange-500 p-1 rounded-lg"><Trophy className="text-white" size={12} /></div>
              <p className="text-sm font-black text-slate-800 leading-none">{score}</p>
            </div>
          )}
          <button onClick={() => setIsFreeMode(!isFreeMode)} className={`px-2 py-1 rounded-lg border text-[9px] font-bold uppercase transition-all ${isFreeMode ? 'bg-purple-100 border-purple-300 text-purple-700' : 'bg-slate-50 border-slate-200 text-slate-500'}`}>
            {isFreeMode ? 'Libre' : 'Reto'}
          </button>
        </div>
        <div className={`px-4 py-1.5 rounded-full border flex items-center gap-2 shadow-inner transition-colors ${isFreeMode ? 'bg-purple-50 border-purple-200' : 'bg-yellow-100 border-yellow-300'}`}>
          <Sparkles className={isFreeMode ? 'text-purple-400' : 'text-yellow-600'} size={12} />
          <span className={`text-[10px] font-black uppercase tracking-tight ${isFreeMode ? 'text-purple-700' : 'text-yellow-700'}`}>
            {isFreeMode ? 'Explora formas hasta el 100' : `Objetivo: ${target}`}
          </span>
        </div>
        <button onClick={() => {setBlocks([]); nextLevel();}} className="p-1.5 bg-slate-50 rounded-full border border-slate-200 text-slate-500"><RotateCcw size={14} /></button>
      </div>

      <div ref={containerRef} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} className="flex-1 relative bg-[radial-gradient(#e2e8f0_1px,transparent_1px)] [background-size:24px_24px] overflow-hidden">
        {blocks.map(block => (
          <NumberBlock key={block.id} id={block.id} value={block.value} width={block.width} x={block.x} y={block.y} onPointerDown={handlePointerDown} onDoubleClick={splitBlock} onRotate={rotateBlock} highlight={highlightId === block.id} />
        ))}
        <div className="absolute bottom-0 w-full h-2 bg-green-500/10 pointer-events-none" />
      </div>

      <div className="bg-white p-2 border-t border-slate-100 flex flex-col items-center gap-2 shadow-inner">
        <div className="flex gap-2">
            <button onClick={() => spawnBlock(1)} className="flex items-center gap-2 bg-red-500 text-white px-4 py-2 rounded-xl shadow-[0_3px_0_rgb(153,27,27)] active:translate-y-1 active:shadow-none transition-all">
                <PlusCircle size={16} /> <span className="text-xs font-bold uppercase tracking-wide">Bloque 1</span>
            </button>
            <button onClick={() => spawnBlock(10)} className="flex items-center gap-2 bg-white text-red-500 border-2 border-red-500 px-4 py-2 rounded-xl shadow-[0_3px_0_rgb(153,27,27)] active:translate-y-1 active:shadow-none transition-all">
                <Zap size={16} /> <span className="text-xs font-bold uppercase tracking-wide">Bloque 10</span>
            </button>
        </div>
        <p className="text-[8px] font-bold text-slate-400 uppercase text-center">
          Usa la rueda del ratón o el botón azul para cambiar la forma del bloque
        </p>
      </div>
    </div>
  );
};

export default App;


