import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Trophy, PlusCircle, RotateCcw, Zap, Sparkles, Layout, Trash2, Scissors, Star, RefreshCw } from 'lucide-react';

/**
 * 游늭 ARCHIVO SUGERIDO: src/hooks/useAudio.js
 * Este bloque contiene la l칩gica del sintetizador. 
 * En un proyecto organizado, lo exportar칤as como un Hook personalizado.
 */
const playSound = (type) => {
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  if (!AudioContext) return;
  
  const ctx = new AudioContext();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  
  osc.connect(gain);
  gain.connect(ctx.destination);
  
  const now = ctx.currentTime;

  switch(type) {
    case 'spawn':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(440, now);
      osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;
    case 'merge':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(330, now);
      osc.frequency.exponentialRampToValueAtTime(660, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'transform':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(523, now);
      osc.frequency.linearRampToValueAtTime(783, now + 0.1);
      osc.frequency.linearRampToValueAtTime(523, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'split':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(660, now);
      osc.frequency.exponentialRampToValueAtTime(220, now + 0.15);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;
    case 'success':
      const notes = [523.25, 659.25, 783.99, 1046.50]; 
      notes.forEach((freq, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.connect(g);
        g.connect(ctx.destination);
        o.frequency.setValueAtTime(freq, now + (i * 0.1));
        g.gain.setValueAtTime(0.05, now + (i * 0.1));
        g.gain.exponentialRampToValueAtTime(0.01, now + (i * 0.1) + 0.3);
        o.start(now + (i * 0.1));
        o.stop(now + (i * 0.1) + 0.3);
      });
      break;
    default:
      break;
  }
};

/**
 * 游늭 ARCHIVO SUGERIDO: src/utils/ids.js
 * Utilidad simple para generar IDs 칰nicos compatibles con selectores CSS.
 */
const generateId = (prefix = 'id') => {
  return `${prefix}_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
};

/**
 * 游늭 ARCHIVO SUGERIDO: src/utils/colors.js
 * Contiene la definici칩n visual de cada Numberblock basada en su valor.
 */
const getBlockStyle = (value) => {
  if (value <= 10) {
    const config = {
      1: { bg: '#FF0000', border: 'rgba(0,0,0,0.15)' },
      2: { bg: '#FF8000', border: 'rgba(0,0,0,0.15)' },
      3: { bg: '#FFFF00', border: 'rgba(0,0,0,0.15)' },
      4: { bg: '#00FF00', border: 'rgba(0,0,0,0.15)' },
      5: { bg: '#00FFFF', border: 'rgba(0,0,0,0.15)' },
      6: { bg: '#8A2BE2', border: 'rgba(0,0,0,0.15)' },
      7: { bg: 'linear-gradient(45deg, #ff0000, #ffff00, #00ff00, #0000ff)', border: 'rgba(0,0,0,0.15)' },
      8: { bg: '#FF69B4', border: 'rgba(0,0,0,0.15)' },
      9: { bg: '#C0C0C0', border: 'rgba(0,0,0,0.15)' },
      10: { bg: '#FFFFFF', border: '#FF0000' },
    };
    return config[value];
  }
  if (value === 100) return { bg: '#FFFFFF', border: '#FF0000', glow: '0 0 25px rgba(255,0,0,0.2)' };
  const tens = Math.floor(value / 10);
  const hue = (tens * 36) % 360;
  return { bg: `hsl(${hue}, 85%, 75%)`, border: value % 10 === 0 ? '#FF0000' : 'rgba(0,0,0,0.12)' };
};

/**
 * 游늭 ARCHIVO SUGERIDO: src/utils/geometry.js
 * L칩gica de validaci칩n de formas (divisores) y geometr칤a adaptativa.
 */
const getValidWidths = (value) => {
  if (value === 1) return [1];
  const widths = [];
  const MAX_HEIGHT = 12;
  const MAX_WIDTH = 10;
  const minWidthRequiredByHeight = Math.ceil(value / MAX_HEIGHT);
  for (let i = minWidthRequiredByHeight; i <= Math.min(value, MAX_WIDTH); i++) {
    if (value % i === 0) {
      const h = value / i;
      if (h <= MAX_HEIGHT && h >= 2) widths.push(i);
    }
  }
  if (widths.length === 0) {
      if (value <= MAX_WIDTH) return [1]; 
      return [minWidthRequiredByHeight || 2];
  }
  return widths;
};

/**
 * 游늭 ARCHIVO SUGERIDO: src/components/NumberBlock.jsx
 * Componente visual que representa a un Numberblock.
 * Deber치s importar: getBlockStyle, getValidWidths, RefreshCw, Scissors, Star.
 */
const NumberBlock = React.memo(({ value, x, y, id, width, onPointerDown, onDoubleClick, onRotate, highlight = false }) => {
  const style = getBlockStyle(value);
  const cols = width || 1;
  const rows = Math.ceil(value / cols);

  let blockSize = 38;
  if (value > 80) blockSize = 18;
  else if (value > 50) blockSize = 22;
  else if (value > 25) blockSize = 28;
  else if (value > 10) blockSize = 32;

  const validWidths = getValidWidths(value);
  const canTransform = validWidths.length > 1;

  return (
    <div
      id={`block-${id}`}
      data-value={value}
      data-width={cols}
      data-bsize={blockSize}
      onPointerDown={(e) => onPointerDown(e, id)}
      onDoubleClick={(e) => { e.stopPropagation(); onDoubleClick(id); }}
      className={`group absolute touch-none select-none flex flex-col-reverse items-center animate-in zoom-in duration-300 ${value === 100 ? 'z-50' : 'z-10'}`}
      style={{
        left: x,
        top: y,
        transform: 'translate(-50%, -100%)',
        cursor: 'grab',
        transition: 'transform 0.15s cubic-bezier(0.2, 0, 0.2, 1)'
      }}
    >
      {(highlight || value === 100) && (
        <div className={`absolute inset-x-[-50px] inset-y-[-40px] blur-3xl rounded-full animate-pulse z-0 ${value === 100 ? 'bg-red-400/20' : 'bg-white/60'}`} />
      )}
      <div className={`relative z-10 transition-all ${highlight ? 'scale-105' : ''}`}>
        {canTransform && (
          <button
            onPointerDown={(e) => { e.stopPropagation(); onRotate(id); }}
            className="absolute -right-8 top-0 bg-white shadow-md rounded-full p-1.5 border border-slate-200 text-sky-500 hover:bg-sky-50 hover:scale-110 active:scale-95 transition-all opacity-0 group-hover:opacity-100 z-50 pointer-events-auto"
          >
            <RefreshCw size={14} />
          </button>
        )}
        <div 
          className="grid gap-0" 
          style={{ 
            gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
            width: `${cols * blockSize}px`,
            border: `1px solid ${style.border}`,
            boxShadow: style.glow || 'none'
          }}
        >
          {Array.from({ length: value }).map((_, i) => {
            const faceIndex = Math.floor(cols / 2);
            const isFaceBlock = i === faceIndex; 
            return (
              <div
                key={i}
                className="relative flex items-center justify-center"
                style={{ 
                  width: `${blockSize}px`,
                  height: `${blockSize}px`,
                  background: style.bg,
                  border: `0.5px solid rgba(0,0,0,0.1)`
                }}
              >
                {isFaceBlock && (
                  <div className={`absolute inset-0 flex flex-col items-center justify-center ${blockSize < 25 ? 'scale-75' : 'scale-90'}`}>
                    <div className="flex gap-1 mb-1">
                      {value === 1 ? (
                        <div className="w-4 h-4 bg-black rounded-full border-2 border-white" />
                      ) : (
                        <>
                          <div className="w-2.5 h-2.5 bg-black rounded-full border-2 border-white" />
                          <div className="w-2.5 h-2.5 bg-black rounded-full border-2 border-white" />
                        </>
                      )}
                    </div>
                    <div className="w-5 h-2 bg-black/25 rounded-full" />
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>
      <div className="mb-1 font-black pointer-events-none z-20 text-black flex items-center gap-1 text-base">
        {value === 100 && <Star size={16} className="fill-red-500 text-red-500 animate-spin-slow" />}
        {value}
        {value === 100 && <Star size={16} className="fill-red-500 text-red-500 animate-spin-slow" />}
      </div>
      {value > 1 && (
        <div className="absolute -top-10 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">
          <Scissors size={14} className="text-slate-400 rotate-90" />
        </div>
      )}
    </div>
  );
});

/**
 * 游늭 ARCHIVO SUGERIDO: src/App.jsx
 * Orquestador principal del juego.
 * Deber치s importar: NumberBlock, playSound, generateId, getValidWidths e iconos de Lucide.
 */
const App = () => {
  const [blocks, setBlocks] = useState([]);
  const [target, setTarget] = useState(10);
  const [score, setScore] = useState(0);
  const [highlightId, setHighlightId] = useState(null);
  const [isFreeMode, setIsFreeMode] = useState(false);
  const containerRef = useRef(null);
  const draggingRef = useRef({ id: null, element: null, offsetX: 0, offsetY: 0, currentX: 0, currentY: 0 });

  const nextLevel = useCallback(() => {
    const newTarget = Math.floor(Math.random() * 91) + 10;
    setTarget(newTarget);
    setTimeout(() => {
        if (!containerRef.current) return;
        const h = containerRef.current.getBoundingClientRect().height;
        setBlocks([
          { id: generateId('b'), value: 1, x: 80, y: h - 10, width: 1 },
          { id: generateId('b'), value: 1, x: 150, y: h - 10, width: 1 }
        ]);
    }, 50);
    setHighlightId(null);
  }, []);

  useEffect(() => { nextLevel(); }, [nextLevel]);

  const rotateBlock = useCallback((id) => {
    playSound('transform');
    setBlocks(prev => prev.map(b => {
      if (b.id !== id) return b;
      const validWidths = getValidWidths(b.value);
      if (validWidths.length <= 1) return b;
      const currentIndex = validWidths.indexOf(b.width);
      const nextIndex = (currentIndex + 1) % validWidths.length;
      return { ...b, width: validWidths[nextIndex] };
    }));
  }, []);

  const spawnBlock = (val) => {
    playSound('spawn');
    const rect = containerRef.current.getBoundingClientRect();
    const widths = getValidWidths(val);
    const initialWidth = widths[0];
    const pixelWidth = initialWidth * (val > 10 ? 28 : 38);
    const safeX = Math.max(pixelWidth/2 + 20, Math.min(rect.width - pixelWidth/2 - 20, Math.random() * rect.width));

    const newBlock = {
      id: generateId('block'),
      value: val,
      x: safeX,
      y: rect.height - 10, 
      width: initialWidth
    };
    setBlocks(prev => [...prev, newBlock]);
  };

  const splitBlock = useCallback((id) => {
    playSound('split');
    setBlocks(prev => {
      const blockToSplit = prev.find(b => b.id === id);
      if (!blockToSplit || blockToSplit.value <= 1) return prev;
      const newValue = blockToSplit.value - 1;
      const widths = getValidWidths(newValue);
      const updatedBlock = { ...blockToSplit, value: newValue, width: widths[0] };
      const newOne = { id: generateId('split'), value: 1, x: blockToSplit.x + 50, y: blockToSplit.y, width: 1 };
      return [...prev.filter(b => b.id !== id), updatedBlock, newOne];
    });
  }, []);

  const checkCollision = (dragId, x, y) => {
    const otherElements = Array.from(document.querySelectorAll(`[id^="block-"]:not([id="block-${dragId}"])`));
    for (let el of otherElements) {
      const rect = el.getBoundingClientRect();
      const containerRect = containerRef.current.getBoundingClientRect();
      const elX = rect.left - containerRect.left + rect.width / 2;
      const elY = rect.bottom - containerRect.top;
      const val = parseInt(el.getAttribute('data-value'));
      const widthUnits = parseInt(el.getAttribute('data-width'));
      const bSize = parseInt(el.getAttribute('data-bsize'));
      const heightUnits = Math.ceil(val / widthUnits);
      const pxWidth = widthUnits * bSize;
      const pxHeight = heightUnits * bSize;
      const thresholdX = (pxWidth / 2) + 25; 
      const thresholdY = 25; 
      const isInsideX = Math.abs(x - elX) < thresholdX;
      const isInsideY = y > (elY - pxHeight - thresholdY) && y < (elY + thresholdY);
      if (isInsideX && isInsideY) return el.id.replace('block-', '');
    }
    return null;
  };

  const handlePointerDown = (e, id) => {
    if (e.target.closest('button')) return;
    const blockElement = document.getElementById(`block-${id}`);
    if (!blockElement) return;
    const rect = containerRef.current.getBoundingClientRect();
    const blockData = blocks.find(b => b.id === id);
    if (!blockData) return;
    draggingRef.current = { id, element: blockElement, offsetX: e.clientX - rect.left - blockData.x, offsetY: e.clientY - rect.top - blockData.y, currentX: blockData.x, currentY: blockData.y };
    blockElement.style.zIndex = "2000";
    blockElement.style.transition = "none";
    blockElement.setPointerCapture(e.pointerId);
  };

  const handlePointerMove = (e) => {
    const state = draggingRef.current;
    if (!state.id || !state.element) return;
    const rect = containerRef.current.getBoundingClientRect();
    const bSize = parseInt(state.element.getAttribute('data-bsize'));
    const cols = parseInt(state.element.getAttribute('data-width'));
    const pixelWidth = cols * bSize;
    let nextX = e.clientX - rect.left - state.offsetX;
    let nextY = e.clientY - rect.top - state.offsetY;
    nextX = Math.max(pixelWidth/2, Math.min(rect.width - pixelWidth/2, nextX));
    state.currentX = nextX;
    state.currentY = nextY;
    state.element.style.left = `${state.currentX}px`;
    state.element.style.top = `${state.currentY}px`;
    const targetId = checkCollision(state.id, state.currentX, state.currentY);
    if (targetId !== highlightId) setHighlightId(targetId);
  };

  const handlePointerUp = (e) => {
    const state = draggingRef.current;
    if (!state.id) return;
    if (state.element) state.element.releasePointerCapture(e.pointerId);
    const targetId = checkCollision(state.id, state.currentX, state.currentY);
    if (targetId) {
      const sourceBlock = blocks.find(b => b.id === state.id);
      const targetBlock = blocks.find(b => b.id === targetId);
      if (sourceBlock && targetBlock) {
        const newValue = sourceBlock.value + targetBlock.value;
        if (newValue <= 100) {
          playSound('merge');
          const remainingBlocks = blocks.filter(b => b.id !== state.id && b.id !== targetId);
          const widths = getValidWidths(newValue);
          const mergedBlock = { id: generateId('merged'), value: newValue, x: targetBlock.x, y: targetBlock.y, width: widths[0] };
          setBlocks([...remainingBlocks, mergedBlock]);
          if (!isFreeMode && newValue === target) {
            playSound('success');
            setScore(s => s + 1);
            setTimeout(() => { setBlocks([]); setTimeout(nextLevel, 400); }, 1500);
          }
        }
      }
    } else {
      setBlocks(prev => prev.map(b => b.id === state.id ? { ...b, x: state.currentX, y: state.currentY } : b));
    }
    if (state.element) {
        state.element.style.zIndex = "10";
        state.element.style.transition = "transform 0.2s, left 0.2s, top 0.2s";
    }
    draggingRef.current = { id: null, element: null, offsetX: 0, offsetY: 0, currentX: 0, currentY: 0 };
    setHighlightId(null);
  };

  return (
    <div className="flex flex-col h-screen bg-sky-50 overflow-hidden font-sans select-none">
      {/* 游늭 COMPONENTE: src/components/Header.jsx */}
      <div className="bg-white p-2 flex justify-between items-center shadow-sm border-b-2 border-sky-100 z-50">
        <div className="flex items-center gap-2">
          {!isFreeMode && (
            <div className="flex items-center gap-1.5">
              <div className="bg-orange-500 p-1 rounded-lg"><Trophy className="text-white" size={12} /></div>
              <p className="text-sm font-black text-slate-800 leading-none">{score}</p>
            </div>
          )}
          <button onClick={() => setIsFreeMode(!isFreeMode)} className="px-2 py-1 rounded-lg border text-[9px] font-bold uppercase transition-all bg-slate-50 border-slate-200 text-slate-500 active:bg-sky-100">
            {isFreeMode ? 'Libre' : 'Reto'}
          </button>
        </div>
        <div className={`px-4 py-1.5 rounded-full border flex items-center gap-2 shadow-inner transition-colors ${isFreeMode ? 'bg-purple-50 border-purple-200' : 'bg-yellow-100 border-yellow-300'}`}>
          <Sparkles className={isFreeMode ? 'text-purple-400' : 'text-yellow-600'} size={12} />
          <span className="text-[11px] font-black uppercase tracking-tight text-slate-700">
            {isFreeMode ? '춰Suma hasta el 100!' : `Objetivo: ${target}`}
          </span>
        </div>
        <button onClick={() => {setBlocks([]); nextLevel();}} className="p-1.5 bg-slate-50 rounded-full border border-slate-200 text-slate-500 hover:bg-red-50 transition-colors"><RotateCcw size={14} /></button>
      </div>

      {/* 츼REA DE JUEGO */}
      <div ref={containerRef} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} className="flex-1 relative bg-[radial-gradient(#e2e8f0_1px,transparent_1px)] [background-size:24px_24px] overflow-hidden pointer-events-auto">
        {blocks.map(block => (
          <NumberBlock key={block.id} id={block.id} value={block.value} width={block.width} x={block.x} y={block.y} onPointerDown={handlePointerDown} onDoubleClick={splitBlock} onRotate={rotateBlock} highlight={highlightId === block.id} />
        ))}
        <div className="absolute bottom-0 w-full h-2 bg-green-500/20 border-t border-green-500/30 pointer-events-none" />
      </div>

      {/* 游늭 COMPONENTE: src/components/GameFooter.jsx */}
      <div className="bg-white p-2 border-t border-slate-100 flex flex-col items-center gap-2 shadow-inner z-50">
        <div className="flex gap-2">
            <button onClick={() => spawnBlock(1)} className="flex items-center gap-2 bg-red-500 text-white px-5 py-3 rounded-2xl shadow-[0_4px_0_rgb(153,27,27)] active:translate-y-1 active:shadow-none transition-all">
                <PlusCircle size={18} /> <span className="text-sm font-bold uppercase tracking-wide">A침adir 1</span>
            </button>
            <button onClick={() => spawnBlock(10)} className="flex items-center gap-2 bg-white text-red-500 border-2 border-red-500 px-5 py-3 rounded-2xl shadow-[0_4px_0_rgb(153,27,27)] active:translate-y-1 active:shadow-none transition-all">
                <Zap size={18} /> <span className="text-sm font-bold uppercase tracking-wide">A침adir 10</span>
            </button>
        </div>
      </div>
    </div>
  );
};

export default App;



